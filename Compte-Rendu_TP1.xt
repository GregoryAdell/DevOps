1-1 Why should we run the container with a flag -e to give the environment variables?

Pour éviter d'avoir les login et mot de passes écris en clair dans un fichier texte facilement lisible comme le Dockerfile.
Exemple avec les identifiants indiqués dans la commande via "-e" :
    docker run -d --name postgres-container --network app-network -e POSTGRES_DB=db -e POSTGRES_USER=user -e POSTGRES_PASSWORD=pwd -p 5432:5432 postgres:14.1-alpine 

--------------------------------------------------------------

1-2 Why do we need a volume to be attached to our postgres container?

--------------------------------------------------------------

1-3 Document your database container essentials: commands and Dockerfile.

--------------------------------------------------------------

1-4 Why do we need a multistage build? And explain each step of this dockerfile.

--------------------------------------------------------------

1-5 Why do we need a reverse proxy?

--------------------------------------------------------------

1-6 Why is docker-compose so important?

--------------------------------------------------------------

1-7 Document docker-compose most important commands. 1-8 Document your docker-compose file.

--------------------------------------------------------------

1-9 Document your publication commands and published images in dockerhub.

--------------------------------------------------------------

1-10 Why do we put our images into an online repo?






1-1 Why should we run the container with a flag -e to give the environment variables?

Pour éviter d'avoir les login et mots de passe écrits en clair dans un fichier texte facilement lisible comme le Dockerfile.
Exemple avec les identifiants indiqués dans la commande via "-e" :

docker run -d --name postgres-container --network app-network -e POSTGRES_DB=db -e POSTGRES_USER=user -e POSTGRES_PASSWORD=pwd -p 5432:5432 postgres:14.1-alpine

1-2 Why do we need a volume to be attached to our postgres container?

Un volume est nécessaire pour assurer la persistance des données. Sans volume, lorsque le conteneur est supprimé, les données stockées dans la base de données sont perdues. En attachant un volume, nous garantissons que les données survivent même après l'arrêt ou la suppression du conteneur.

Exemple de commande pour attacher un volume :

docker run -d --name postgres-container --network app-network -e POSTGRES_DB=db -e POSTGRES_USER=user -e POSTGRES_PASSWORD=pwd -v /my/own/datadir:/var/lib/postgresql/data -p 5432:5432 postgres:14.1-alpine

1-3 Document your database container essentials: commands and Dockerfile.

Dockerfile :

FROM postgres:14.1-alpine
ENV POSTGRES_DB=db \
    POSTGRES_USER=usr \
    POSTGRES_PASSWORD=pwd
COPY ./init-scripts/ /docker-entrypoint-initdb.d/

Commandes essentielles :

Créer le réseau :

docker network create app-network

Construire l'image :

docker build -t my-postgres-db .

Lancer le conteneur :

docker run -d --name postgres-container --network app-network -v /my/own/datadir:/var/lib/postgresql/data -p 5432:5432 my-postgres-db

1-4 Why do we need a multistage build? And explain each step of this dockerfile.

Un multistage build permet d'optimiser l'image Docker en séparant les étapes de compilation et d'exécution. Cela réduit la taille de l'image finale en ne conservant que les fichiers nécessaires.

Explication du Dockerfile :

FROM eclipse-temurin:21-jdk-alpine AS build
WORKDIR /usr/src/app
COPY . .
RUN javac Main.java

FROM eclipse-temurin:21-jre-alpine
WORKDIR /usr/src/app
COPY --from=build /usr/src/app/Main.class .
CMD ["java", "Main"]

Première étape (build stage) :

Utilisation d'une image contenant le JDK.

Copie des fichiers sources et compilation du code.

Deuxième étape (run stage) :

Utilisation d'une image plus légère contenant uniquement le JRE.

Copie du fichier .class généré et exécution de l'application Java.

1-5 Why do we need a reverse proxy?

Un reverse proxy permet de :

Centraliser et sécuriser l'accès aux services.

Servir de point unique d'entrée pour différentes applications backend.

Améliorer la performance en mettant en cache certaines réponses.

Faciliter le load balancing.

Dans notre cas, Apache servira de proxy pour rediriger les requêtes vers notre backend Spring Boot.

1-6 Why is docker-compose so important?

Docker Compose simplifie la gestion des conteneurs en permettant de :

Définir et orchestrer plusieurs services dans un fichier unique (docker-compose.yml).

Automatiser le démarrage, l'arrêt et la mise à jour des conteneurs.

Gérer facilement les réseaux et les volumes partagés entre services.

1-7 Document docker-compose most important commands. 1-8 Document your docker-compose file.

Commandes essentielles :

Lancer les services définis :

docker-compose up -d

Arrêter les services :

docker-compose down

Recréer les conteneurs après modification du Dockerfile :

docker-compose up --build -d

Fichier docker-compose.yml :

version: '3.7'

services:
  database:
    build: ./database
    networks:
      - my-network
    volumes:
      - db-data:/var/lib/postgresql/data

  backend:
    build: ./backend
    networks:
      - my-network
    depends_on:
      - database

  httpd:
    build: ./httpd
    ports:
      - "80:80"
    networks:
      - my-network
    depends_on:
      - backend

networks:
  my-network:
volumes:
  db-data:

1-9 Document your publication commands and published images in dockerhub.

Se connecter à Docker Hub :

docker login

Taguer l’image :

docker tag my-database USERNAME/my-database:1.0

Pousser l’image sur Docker Hub :

docker push USERNAME/my-database:1.0

1-10 Why do we put our images into an online repo?

Partage avec l'équipe et accès depuis différentes machines.

Déploiement facile sur des serveurs distants.

Maintien d'un historique des versions d'images.

Réduction de la charge sur les CI/CD pipelines en évitant de reconstruire les images à chaque déploiement.

